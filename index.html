<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Job Planner</title>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="layout.css" />
	</head>
	<body>
		<header class="topbar">
			<div class="brand">Job Planner</div>
			<div class="controls">
				<!-- login removed: app is single-user client-only -->
				<button id="fireworkBtn" class="firework-btn" title="Show fireworks" aria-label="Show fireworks">ðŸŽ†</button>
			</div>
		</header>

		<main>
			<div id="boards" class="boards"></div>
			<div id="empty" class="empty">Create a board to get started</div>
		</main>

		<!-- login removed; single-user demo -->

		<!-- Detail Modal -->
		<div id="detailModal" class="modal hidden">
			<div class="modal-card">
				<h3 id="modalTitle" style="margin-top:0"></h3>
				<div id="modalDesc" style="margin:12px 0; white-space: pre-wrap; color: #4b5563;"></div>
				<div id="modalTime" class="muted" style="margin-bottom:16px; font-size: 0.9em;"></div>
				<div style="text-align:right">
					<button id="closeModal" style="background:var(--primary); color:white; border:none; padding:8px 16px; border-radius:6px;">Close</button>
				</div>
			</div>
		</div>

		<!-- Add-board button -->
		<div class="add-board">
			<input id="newBoardName" placeholder="New board name" />
			<button id="createBoard">Create Board</button>
		</div>

		<template id="list-template">
			<div class="list">
				<div class="list-header">
					<h4 class="list-title"></h4>
					<button class="add-card">ï¼‹</button>
				</div>
				<div class="cards"></div>
				<div class="add-card-row hidden">
					<input class="card-title" placeholder="Card title" />
					<textarea class="card-desc" placeholder="Description (optional)" rows="3"></textarea>
					<div class="row">
						<div class="time-field">
							<div class="time-label">Start Time</div>
							<input class="card-start" type="text" placeholder="Selectâ€¦" readonly />
							<div class="inline-picker start-picker hidden">
								<div class="picker-row">
									<input class="start-date" type="date" />
									<input class="start-time" type="time" />
								</div>
								<div class="picker-actions">
									<button class="apply-start">Apply</button>
									<button class="cancel-start">Cancel</button>
								</div>
							</div>
						</div>
						<div class="time-field">
							<div class="time-label">End Time</div>
							<input class="card-end" type="text" placeholder="Selectâ€¦" readonly />
							<div class="inline-picker end-picker hidden">
								<div class="picker-row">
									<input class="end-date" type="date" />
									<input class="end-time" type="time" />
								</div>
								<div class="picker-actions">
									<button class="apply-end">Apply</button>
									<button class="cancel-end">Cancel</button>
								</div>
							</div>
						</div>
					</div>
						<div class="row">
							<button class="save-card">Add</button>
						<button class="cancel-card">Cancel</button>
					</div>
				</div>
			</div>
		</template>

		<template id="card-template">
			<div class="card-item">
				<div class="card-main">
					<div class="card-title-text"></div>
					<div class="card-due-text muted"></div>
				</div>
				<div class="card-actions">
					<button class="details-btn" title="View Details">
						<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
					</button>
					<button class="doing">Doing</button>
					<button class="complete">Done</button>
				</div>
				<div class="countdown muted"></div>
			</div>
		</template>

		<script>
			// Minimal client-side Trello-like app.
			// Data model stored in localStorage under key 'mt_data'
			const STORAGE_KEY = 'mt_data_v1';
			// DOM refs
			const boardsEl = document.getElementById('boards');
			const emptyEl = document.getElementById('empty');
			const createBoardBtn = document.getElementById('createBoard');
			const newBoardName = document.getElementById('newBoardName');

			const listTemplate = document.getElementById('list-template');
			const cardTemplate = document.getElementById('card-template');

			// app state
			let state = loadState();

			function loadState(){
				try{ const s = JSON.parse(localStorage.getItem(STORAGE_KEY)); return s || { boards: [] }; }catch(e){ return { boards: [] }; }
			}

			function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

			// === Workflow helpers (small task board) ===
			function getList(board, listName){ return board.lists.find(l => l.name.toLowerCase() === listName.toLowerCase()); }
			function ensureList(board, listName){
				let l = getList(board, listName);
				if(!l){ l = { name: listName, cards: [] }; board.lists.push(l); saveState(); }
				return l;
			}
			function moveCardWithinBoard(cardId, boardId, fromListName, toListName){
				const board = state.boards.find(b => b.id === boardId);
				if(!board) return false;
				let fromList = getList(board, fromListName);
				// If not found in the expected list, search across all lists to be robust
				let idx = fromList ? fromList.cards.findIndex(c => c.id === cardId) : -1;
				if(idx === -1){
					for(const l of board.lists){
						const i = l.cards.findIndex(c => c.id === cardId);
						if(i !== -1){ fromList = l; idx = i; break; }
					}
				}
				if(!fromList || idx === -1) return false;
				const [card] = fromList.cards.splice(idx,1);
				const toList = ensureList(board, toListName);
				toList.cards.push(card);
				saveState();
				return true;
			}
			// schedule a future move within the same board (demo; will not survive reload)
			function scheduleMove(when, cardId, boardId, fromListName, toListName){
				const now = Date.now(); const ts = typeof when === 'string' ? Date.parse(when) : when instanceof Date ? when.getTime() : now;
				const delay = Math.max(0, ts - now);
				setTimeout(()=>{ moveCardWithinBoard(cardId, boardId, fromListName, toListName); render(); }, delay);
			}

			// compose local date+time into a Unix timestamp (ms since epoch)
			function toLocalTs(dateStr, timeStr){
				try{
					const [y,m,d] = dateStr.split('-').map(Number);
					const [hh,mm] = timeStr.split(':').map(Number);
					const dt = new Date(y, (m||1)-1, d||1, hh||0, mm||0, 0);
					return dt.getTime();
				}catch(e){ return null; }
			}

			function moveCardAcrossBoards(cardId, fromBoardId, fromListName, toBoardId, toListName){
				const fromBoard = state.boards.find(b => b.id === fromBoardId);
				const toBoard = state.boards.find(b => b.id === toBoardId);
				if(!fromBoard || !toBoard) return false;
				let fromList = getList(fromBoard, fromListName);
				let idx = fromList ? fromList.cards.findIndex(c => c.id === cardId) : -1;
				if(idx === -1){
					for(const l of fromBoard.lists){ const i = l.cards.findIndex(c => c.id === cardId); if(i !== -1){ fromList = l; idx = i; break; } }
				}
				if(!fromList || idx === -1) return false;
				const [card] = fromList.cards.splice(idx,1);
				const toList = getList(toBoard, toListName) || ensureList(toBoard, toListName);
				toList.cards.push(card);
				saveState();
				return true;
			}



			function render(){
				boardsEl.innerHTML = '';
				if(state.boards.length === 0){ emptyEl.style.display = 'block'; } else { emptyEl.style.display = 'none'; }
				state.boards.forEach((board, bi) =>{
					const boardEl = document.createElement('section');
					// mark small task board if it has only one list (our small-board default)
					boardEl.className = 'board' + (board.lists && board.lists.length === 1 ? ' small-board' : '');
					boardEl.innerHTML = `<div class="board-header"><h3>${escapeHtml(board.name)}</h3><button class="delete-board" title="Delete board">Ã—</button></div><div class='lists'></div>`;
					// tag the element with the board id for external control/animations
					boardEl.dataset.boardId = board.id;
					const listsEl = boardEl.querySelector('.lists');
					
						// Delete button delegates to global requestDeleteBoard so we can animate first (no pop-up)
						const deleteBtn = boardEl.querySelector('.delete-board');
						deleteBtn.addEventListener('click', () => {
							if (window.requestDeleteBoard) window.requestDeleteBoard(board.id);
							else { state.boards.splice(bi, 1); saveState(); render(); }
						});
					board.lists.forEach((list, li) =>{
						const node = listTemplate.content.cloneNode(true);
						const listEl = node.querySelector('.list');
						node.querySelector('.list-title').textContent = list.name;
						const addBtn = node.querySelector('.add-card');
						const addRow = node.querySelector('.add-card-row');
						const saveBtn = node.querySelector('.save-card');
						const cancelBtn = node.querySelector('.cancel-card');
						const titleInput = node.querySelector('.card-title');
						const descInput = node.querySelector('.card-desc');
						const startInput = node.querySelector('.card-start');
						const endInput = node.querySelector('.card-end');
						const startPicker = node.querySelector('.start-picker');
						const endPicker = node.querySelector('.end-picker');
						const startDate = node.querySelector('.start-date');
						const startTime = node.querySelector('.start-time');
						const endDate = node.querySelector('.end-date');
						const endTime = node.querySelector('.end-time');
						const applyStartBtn = node.querySelector('.apply-start');
						const cancelStartBtn = node.querySelector('.cancel-start');
						const applyEndBtn = node.querySelector('.apply-end');
						const cancelEndBtn = node.querySelector('.cancel-end');
						const cardsContainer = node.querySelector('.cards');

						addBtn.addEventListener('click', ()=>{ addRow.classList.toggle('hidden'); titleInput.focus(); });
						// open custom pickers
						startInput.addEventListener('click', ()=>{ startPicker.classList.remove('hidden'); });
						endInput.addEventListener('click', ()=>{ endPicker.classList.remove('hidden'); });
						cancelStartBtn.addEventListener('click', ()=>{ startPicker.classList.add('hidden'); });
						cancelEndBtn.addEventListener('click', ()=>{ endPicker.classList.add('hidden'); });
											applyStartBtn.addEventListener('click', ()=>{
												if(startDate.value && startTime.value){
													const ts = toLocalTs(startDate.value, startTime.value);
													startInput.value = `${startDate.value} ${startTime.value}`;
													startInput.dataset.ts = String(ts);
												}
												startPicker.classList.add('hidden');
											});
											applyEndBtn.addEventListener('click', ()=>{
												if(endDate.value && endTime.value){
													const ts = toLocalTs(endDate.value, endTime.value);
													endInput.value = `${endDate.value} ${endTime.value}`;
													endInput.dataset.ts = String(ts);
												}
												endPicker.classList.add('hidden');
											});
						cancelBtn.addEventListener('click', ()=>{ 
							addRow.classList.add('hidden'); 
							titleInput.value=''; 
							if(descInput) descInput.value='';
							if(startInput){ startInput.value=''; startInput.dataset.ts=''; } 
							if(endInput){ endInput.value=''; endInput.dataset.ts=''; } 
						});




											saveBtn.addEventListener('click', ()=>{
							const title = titleInput.value.trim();
							const description = descInput ? descInput.value.trim() : '';
												const startTs = startInput && startInput.dataset.ts ? Number(startInput.dataset.ts) : null;
												const endTs = endInput && endInput.dataset.ts ? Number(endInput.dataset.ts) : null;
							if(!title) return alert('Title required');
												if(startTs && endTs){
													if(endTs < startTs){
									alert('End Time cannot be earlier than Start Time');
									return;
								}
							}
												const start = startTs ? new Date(startTs).toISOString() : null;
												const end = endTs ? new Date(endTs).toISOString() : null;
												const card = { id: Date.now()+Math.random(), title, description, start, end, created: new Date().toISOString(), done: false };
							state.boards[bi].lists[li].cards.push(card);
							saveState();
							render();
							// schedule moves based on start/end times within same (small) board
							try{
								const currentBoardId = state.boards[bi].id;
								const now = new Date();
								if(start){
									const startAt = new Date(start);
									if(startAt <= now){
										// if start is now/past, move to Doing immediately
										moveCardWithinBoard(card.id, currentBoardId, list.name, 'Doing');
										render();
									} else {
										// schedule move to Doing
										scheduleMove(startAt, card.id, currentBoardId, list.name, 'Doing');
									}
								}
								if(end){
									const endAt = new Date(end);
									// Only schedule if end is in the future and, if start exists, end is after start
									if(endAt > now && (!start || endAt > new Date(start))){
										// schedule move to Done from whichever list contains the card at execution
										scheduleMove(endAt, card.id, currentBoardId, 'Doing', 'Done');
									}
								}
							}catch(e){ /* non-blocking */ }

							// Inline time fields replace pop-up workflow; nothing to do here.
						});

						// render cards
						list.cards.forEach(card =>{
							const cnode = cardTemplate.content.cloneNode(true);
							cnode.querySelector('.card-title-text').textContent = card.title;
							// Show a concise status label under the title (Start or End)
							const dueTextEl = cnode.querySelector('.card-due-text');
							const nowT = Date.now();
							const startT = card.start ? Date.parse(card.start) : null;
							const endT = card.end ? Date.parse(card.end) : null;
							
							if(startT && nowT < startT){
								dueTextEl.textContent = 'Starts: ' + new Date(card.start).toLocaleString();
							} else if(endT && nowT < endT){
								dueTextEl.textContent = 'Ends: ' + new Date(card.end).toLocaleString();
							} else { dueTextEl.textContent = ''; }
							
							const completeBtn = cnode.querySelector('.complete');
							const doingBtn = cnode.querySelector('.doing');
							const cardEl = cnode.querySelector('.card-item');
							// Enable drag & drop
							cardEl.draggable = true;
							cardEl.dataset.cardId = String(card.id);
							cardEl.dataset.boardId = String(state.boards[bi].id);
							cardEl.dataset.listName = list.name;
							cardEl.addEventListener('dragstart', (ev)=>{
								const dt = ev.dataTransfer; if(!dt) return;
								dt.setData('text/plain', JSON.stringify({ cardId: card.id, fromBoardId: state.boards[bi].id, fromListName: list.name }));
								ev.dataTransfer.effectAllowed = 'move';
							});
							if(card.done) cardEl.classList.add('done');

							const detailsBtn = cnode.querySelector('.details-btn');
							detailsBtn.addEventListener('click', ()=>{
								const modal = document.getElementById('detailModal');
								const mTitle = document.getElementById('modalTitle');
								const mDesc = document.getElementById('modalDesc');
								const mTime = document.getElementById('modalTime');
								
								mTitle.textContent = card.title;
								mDesc.textContent = card.description || 'No description provided.';
								
								let timeText = '';
								if(card.start) timeText += 'Start: ' + new Date(card.start).toLocaleString() + '\n';
								if(card.end) timeText += 'End: ' + new Date(card.end).toLocaleString();
								mTime.textContent = timeText;
								
								modal.classList.remove('hidden');
							});

							// Doing button logic
							if(list.name === 'Doing' || card.done) doingBtn.style.display = 'none';
							doingBtn.addEventListener('click', ()=>{
								ensureList(state.boards[bi], 'Doing');
								moveCardWithinBoard(card.id, state.boards[bi].id, list.name, 'Doing');
								render();
							});

							completeBtn.addEventListener('click', (ev)=>{
								// compute next state first
								const willBeDone = !card.done;
								// celebrate at the card position before we re-render (read bounding rect while element is in DOM)
								if(willBeDone){
									try{
										const rect = cardEl.getBoundingClientRect();
										if(window.showFireworks) window.showFireworks({ getBoundingClientRect: () => rect });
									}catch(e){}
								}
								card.done = willBeDone;
								saveState(); render();
								// If just marked done, move to Done board -> Done list
								try{
									if(willBeDone){
										const currentBoardId = state.boards[bi].id;
										// ensure list within same board and move
										ensureList(state.boards[bi], 'Done');
										moveCardWithinBoard(card.id, currentBoardId, list.name, 'Done');
										render();
									}
								}catch(e){ /* non-blocking */ }
							});
							// Set countdown independent of list: prioritize upcoming Start, then upcoming End
							const countdown = cnode.querySelector('.countdown');
							
							if(startT && nowT < startT){ countdown.dataset.due = card.start; countdown.dataset.what = 'Start in'; }
							else if(endT && nowT < endT){ countdown.dataset.due = card.end; countdown.dataset.what = 'End in'; }
							else { countdown.dataset.due = ''; countdown.textContent = ''; countdown.removeAttribute('data-what'); }
							
							cardsContainer.appendChild(cnode);
							// entrance animation for the new card
							requestAnimationFrame(()=>{ if(cardEl) cardEl.classList.add('enter'); });
						});

							// Make lists drop targets
							listEl.addEventListener('dragover', (ev)=>{ ev.preventDefault(); if(ev.dataTransfer) ev.dataTransfer.dropEffect = 'move'; });
							listEl.addEventListener('drop', (ev)=>{
								ev.preventDefault();
								try{
									const data = ev.dataTransfer.getData('text/plain');
									const payload = JSON.parse(data);
									const { cardId, fromBoardId, fromListName } = payload;
									const toBoardId = state.boards[bi].id;
									const toListName = list.name;
									if(fromBoardId === toBoardId){
										moveCardWithinBoard(cardId, toBoardId, fromListName, toListName);
									} else {
										moveCardAcrossBoards(cardId, fromBoardId, fromListName, toBoardId, toListName);
									}
									render();
								}catch(e){ /* ignore malformed drops */ }
							});

							listsEl.appendChild(node);
					});

					boardsEl.appendChild(boardEl);
					// small entrance animation for the board
					requestAnimationFrame(()=> boardEl.classList.add('enter'));
				});
				// start countdown updater
				startTicker();
			}

			function escapeHtml(s){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]); }

			// basic ticker: updates countdowns and triggers notification if due
			let tickerId = null;
			function startTicker(){ if(tickerId) return; tickerId = setInterval(tick, 1000); tick(); }
			function stopTicker(){ if(tickerId){ clearInterval(tickerId); tickerId = null; } }

			function tick(){
				document.querySelectorAll('.countdown').forEach(el=>{
					const due = el.dataset.due; if(!due) { el.textContent = ''; return; }
					const label = el.dataset.what || 'Due in';
					const ms = new Date(due) - new Date();
					if(ms <= 0){
						el.textContent = (label === 'Start in') ? 'Starts now' : (label === 'End in') ? 'Ends now' : 'Due now';
						// notify once and clear to avoid repeat spam
						if(!el.dataset.notified){
							const title = el.previousElementSibling.querySelector('.card-title-text')?.textContent || 'Task';
							notify(label.replace(' in','') + ' reached', title);
							el.dataset.notified = '1';
						}
					} else {
						el.textContent = label + ' ' + formatMs(ms);
					}
				});
			}

			function formatMs(ms){
				const s = Math.floor(ms/1000);
				const d = Math.floor(s/86400); const h = Math.floor((s%86400)/3600); const m = Math.floor((s%3600)/60); const sec = s%60;
				return (d?d+'d ':'') + (h?h+'h ':'') + (m?m+'m ':'') + sec+'s';
			}

			function notify(title, body){
				if(Notification.permission === 'granted'){ new Notification(title, { body }); }
				else if(Notification.permission !== 'denied'){
					Notification.requestPermission().then(p => { if(p==='granted') new Notification(title,{body}); });
				}
			}

			function scheduleReminder(card){
				if(!card.due) return;
				// For demo, rely on in-page tick to notify. In production, server-side scheduled tasks or push notifications required.
				// No-op here because tick will handle notification when due.
			}



			createBoardBtn.addEventListener('click', ()=>{
				const name = newBoardName.value.trim(); if(!name) return alert('Enter board name');
				// Small task board: start with a single 'To Do' list by default
				state.boards.push({ id: Date.now()+Math.random(), name, lists: [ { name: 'To Do', cards: [] } ] });
				newBoardName.value = '';
				saveState(); render();
			});

					render();

			// Modal close logic
			const detailModal = document.getElementById('detailModal');
			const closeModalBtn = document.getElementById('closeModal');
			if(closeModalBtn){
				closeModalBtn.addEventListener('click', ()=>{
					detailModal.classList.add('hidden');
				});
			}
			if(detailModal){
				detailModal.addEventListener('click', (e)=>{
					if(e.target === detailModal) detailModal.classList.add('hidden');
				});
			}

			// request notification permission on first load (non-blocking)
			if('Notification' in window && Notification.permission === 'default') Notification.requestPermission();
		</script>
		<script src="scripts.js"></script>
	</body>
</html>