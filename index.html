<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Mini Trello — Demo</title>
		<link rel="stylesheet" href="layout.css" />
	</head>
	<body>
		<header class="topbar">
			<div class="brand">MiniTrello</div>
			<div class="controls">
				<span id="userDisplay" class="user"></span>
				<button id="loginBtn">Log in</button>
				<button id="logoutBtn" class="hidden">Log out</button>
			</div>
		</header>

		<main>
			<div id="boards" class="boards"></div>
			<div id="empty" class="empty">Create a board to get started</div>
		</main>

		<!-- Login modal -->
		<div id="modal" class="modal hidden">
			<div class="modal-card">
				<button id="modalCloseBtn" class="modal-close" aria-label="Close">×</button>
				<h3>Sign in</h3>
				<form id="loginForm">
					<label>Username</label>
					<input id="username" autocomplete="username" />
					<label>Password</label>
					<input id="password" type="password" autocomplete="current-password" />
					<div class="row">
						<button type="submit">Sign in</button>
						<button id="closeModal" type="button">Cancel</button>
					</div>
				</form>
				<p class="muted">Demo account: user / pass</p>
			</div>
		</div>

		<!-- Add-board button -->
		<div class="add-board">
			<input id="newBoardName" placeholder="New board name" />
			<button id="createBoard">Create Board</button>
		</div>

		<template id="list-template">
			<div class="list">
				<div class="list-header">
					<h4 class="list-title"></h4>
					<button class="add-card">＋</button>
				</div>
				<div class="cards"></div>
				<div class="add-card-row hidden">
					<input class="card-title" placeholder="Card title" />
					<input class="card-due" type="datetime-local" />
					<div class="row">
						<button class="save-card">Add</button>
						<button class="cancel-card">Cancel</button>
					</div>
				</div>
			</div>
		</template>

		<template id="card-template">
			<div class="card-item">
				<div class="card-main">
					<div class="card-title-text"></div>
					<div class="card-due-text muted"></div>
				</div>
				<div class="card-actions">
					<button class="complete">Done</button>
				</div>
				<div class="countdown muted"></div>
			</div>
		</template>

		<script>
			// Minimal client-side Trello-like app.
			// Data model stored in localStorage under key 'mt_data'
			const STORAGE_KEY = 'mt_data_v1';
			const USER_KEY = 'mt_user';

			// Simple mock login
			const MOCK = { username: 'user', password: 'pass' };

			// DOM refs
			const loginBtn = document.getElementById('loginBtn');
			const logoutBtn = document.getElementById('logoutBtn');
			const modal = document.getElementById('modal');
			const loginForm = document.getElementById('loginForm');
			const closeModal = document.getElementById('closeModal');
			const userDisplay = document.getElementById('userDisplay');
			const boardsEl = document.getElementById('boards');
			const emptyEl = document.getElementById('empty');
			const createBoardBtn = document.getElementById('createBoard');
			const newBoardName = document.getElementById('newBoardName');

			const listTemplate = document.getElementById('list-template');
			const cardTemplate = document.getElementById('card-template');

			// app state
			let state = loadState();

			function loadState(){
				try{ const s = JSON.parse(localStorage.getItem(STORAGE_KEY)); return s || { boards: [] }; }catch(e){ return { boards: [] }; }
			}

			function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

					function setUser(u){ localStorage.setItem(USER_KEY, JSON.stringify(u)); renderAuth(); }
					function clearUser(){ localStorage.removeItem(USER_KEY); renderAuth(); }
					// Robust getUser: validate parsed value before returning. If invalid, remove it and return null.
					function getUser(){
						try{
							const raw = localStorage.getItem(USER_KEY);
							if(!raw) return null;
							const parsed = JSON.parse(raw);
							if(parsed && typeof parsed === 'object' && 'username' in parsed) return parsed;
							// invalid stored value: remove it
							localStorage.removeItem(USER_KEY);
							return null;
						}catch(e){
							localStorage.removeItem(USER_KEY);
							return null;
						}
					}

					// Helper to remove user from storage programmatically
					function removeUser(){ localStorage.removeItem(USER_KEY); location.reload(); }
					window.removeUser = removeUser;

			function renderAuth(){
				const u = getUser();
				if(u){ userDisplay.textContent = u.username; loginBtn.classList.add('hidden'); logoutBtn.classList.remove('hidden'); }
				else { userDisplay.textContent = ''; loginBtn.classList.remove('hidden'); logoutBtn.classList.add('hidden'); }
			}

			function render(){
				boardsEl.innerHTML = '';
				if(state.boards.length === 0){ emptyEl.style.display = 'block'; } else { emptyEl.style.display = 'none'; }
				state.boards.forEach((board, bi) =>{
					const boardEl = document.createElement('section');
					boardEl.className = 'board';
					boardEl.innerHTML = `<h3>${escapeHtml(board.name)}</h3><div class='lists'></div>`;
					const listsEl = boardEl.querySelector('.lists');
					board.lists.forEach((list, li) =>{
						const node = listTemplate.content.cloneNode(true);
						const listEl = node.querySelector('.list');
						node.querySelector('.list-title').textContent = list.name;
						const addBtn = node.querySelector('.add-card');
						const addRow = node.querySelector('.add-card-row');
						const saveBtn = node.querySelector('.save-card');
						const cancelBtn = node.querySelector('.cancel-card');
						const titleInput = node.querySelector('.card-title');
						const dueInput = node.querySelector('.card-due');
						const cardsContainer = node.querySelector('.cards');

						addBtn.addEventListener('click', ()=>{ addRow.classList.toggle('hidden'); titleInput.focus(); });
						cancelBtn.addEventListener('click', ()=>{ addRow.classList.add('hidden'); titleInput.value=''; dueInput.value=''; });
						saveBtn.addEventListener('click', ()=>{
							const title = titleInput.value.trim();
							const due = dueInput.value ? new Date(dueInput.value).toISOString() : null;
							if(!title) return alert('Title required');
							const card = { id: Date.now()+Math.random(), title, due, created: new Date().toISOString(), done: false };
							state.boards[bi].lists[li].cards.push(card);
							saveState();
							render();
							// schedule notification if due
							scheduleReminder(card);
						});

						// render cards
						list.cards.forEach(card =>{
							const cnode = cardTemplate.content.cloneNode(true);
							cnode.querySelector('.card-title-text').textContent = card.title;
							cnode.querySelector('.card-due-text').textContent = card.due ? new Date(card.due).toLocaleString() : '';
							const completeBtn = cnode.querySelector('.complete');
							const cardEl = cnode.querySelector('.card-item');
							if(card.done) cardEl.classList.add('done');
							completeBtn.addEventListener('click', ()=>{
								card.done = !card.done;
								if(card.done) onComplete(card);
								saveState(); render();
							});
							// set countdown element dataset for ticking
							const countdown = cnode.querySelector('.countdown');
							if(card.due && !card.done){ countdown.dataset.due = card.due; }
							cardsContainer.appendChild(cnode);
						});

						listsEl.appendChild(node);
					});

					boardsEl.appendChild(boardEl);
				});
				// start countdown updater
				startTicker();
			}

			function escapeHtml(s){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]); }

			// basic ticker: updates countdowns and triggers notification if due
			let tickerId = null;
			function startTicker(){ if(tickerId) return; tickerId = setInterval(tick, 1000); tick(); }
			function stopTicker(){ if(tickerId){ clearInterval(tickerId); tickerId = null; } }

			function tick(){
				document.querySelectorAll('.countdown').forEach(el=>{
					const due = el.dataset.due; if(!due) { el.textContent = ''; return; }
					const ms = new Date(due) - new Date();
					if(ms <= 0){ el.textContent = 'Due now';
						// notify and clear dataset so we don't notify continuously
						if(!el.dataset.notified){ notify('Task due', el.previousElementSibling.querySelector('.card-title-text')?.textContent || 'Task is due'); el.dataset.notified = '1'; }
					} else {
						el.textContent = formatMs(ms);
					}
				});
			}

			function formatMs(ms){
				const s = Math.floor(ms/1000);
				const d = Math.floor(s/86400); const h = Math.floor((s%86400)/3600); const m = Math.floor((s%3600)/60); const sec = s%60;
				return (d?d+'d ':'') + (h?h+'h ':'') + (m?m+'m ':'') + sec+'s';
			}

			function notify(title, body){
				if(Notification.permission === 'granted'){ new Notification(title, { body }); }
				else if(Notification.permission !== 'denied'){
					Notification.requestPermission().then(p => { if(p==='granted') new Notification(title,{body}); });
				}
			}

			function scheduleReminder(card){
				if(!card.due) return;
				// For demo, rely on in-page tick to notify. In production, server-side scheduled tasks or push notifications required.
				// No-op here because tick will handle notification when due.
			}

			// streaks: if user completes at least one task each day for 5 consecutive days they get a reward.
			function onComplete(card){
				const u = getUser(); if(!u) return;
				// record completion date (local date string)
				const completions = (u.completions = u.completions || []);
				completions.push(new Date().toISOString());
				// normalize to date strings and reduce to unique last N days
				u.completions = completions;
				setUser(u);
				checkStreak(u);
			}

			function checkStreak(u){
				const dates = (u.completions || []).map(d=>new Date(d).toISOString().slice(0,10));
				const unique = Array.from(new Set(dates)).sort();
				// count consecutive days ending today
				let streak = 0; const today = new Date();
				for(let i=0;;i++){
					const day = new Date(); day.setDate(today.getDate() - i);
					const dayStr = day.toISOString().slice(0,10);
					if(unique.includes(dayStr)) streak++; else break;
				}
				if(streak >= 5){ // reward
					alert('Congratulations! You have a 5-day streak. Reward unlocked!');
					notify('Streak reward', '5-day consistency reward unlocked');
					// clear completions to avoid repeated alerts (or keep and mark reward given)
					u.lastReward = new Date().toISOString();
					setUser(u);
				}
			}

					// UI actions
					function openSignIn(){
						modal.classList.remove('hidden');
						const u = document.getElementById('username'); if(u) u.focus();
					}
					window.openSignIn = openSignIn;
					loginBtn.addEventListener('click', openSignIn);
					function closeSignIn(){
						// hide modal and clear fields
						modal.classList.add('hidden');
						const u = document.getElementById('username');
						const p = document.getElementById('password');
						if(u) u.value = '';
						if(p) p.value = '';
					}
					// expose for programmatic use
					window.closeSignIn = closeSignIn;
					closeModal.addEventListener('click', closeSignIn);
					const modalCloseBtn = document.getElementById('modalCloseBtn');
					if(modalCloseBtn) modalCloseBtn.addEventListener('click', closeSignIn);
					// Close modal when clicking on the overlay (outside the modal-card)
					modal.addEventListener('click', function(e){
						if(e.target === modal) closeSignIn();
					});
			logoutBtn.addEventListener('click', ()=>{ setUser({ username: 'Guest', completions: [] }); renderAuth(); });

			loginForm.addEventListener('submit', e=>{
				e.preventDefault();
				const u = document.getElementById('username').value.trim();
				const p = document.getElementById('password').value;
				if(u === MOCK.username && p === MOCK.password){ setUser({ username: u }); modal.classList.add('hidden'); renderAuth(); }
				else alert('Invalid credentials (demo)');
			});

			createBoardBtn.addEventListener('click', ()=>{
				const name = newBoardName.value.trim(); if(!name) return alert('Enter board name');
				state.boards.push({ id: Date.now()+Math.random(), name, lists: [ { name: 'To Do', cards: [] }, { name: 'Doing', cards: [] }, { name: 'Done', cards: [] } ] });
				newBoardName.value = '';
				saveState(); render();
			});

							// initialize
							// If no user is present, create a guest session so the app is usable without logging in.
							if(!getUser()){
								setUser({ username: 'Guest', completions: [] });
							}
							renderAuth(); render();

			// request notification permission on first load (non-blocking)
			if('Notification' in window && Notification.permission === 'default') Notification.requestPermission();
		</script>
	</body>
</html>