<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Job Planner</title>
		<link rel="stylesheet" href="layout.css" />
	</head>
	<body>
		<header class="topbar">
			<div class="brand">Job Planner</div>
			<div class="controls">
				<!-- login removed: app is single-user client-only -->
			</div>
		</header>

		<main>
			<div id="boards" class="boards"></div>
			<div id="empty" class="empty">Create a board to get started</div>
		</main>

		<!-- login removed; single-user demo -->

		<!-- Add-board button -->
		<div class="add-board">
			<input id="newBoardName" placeholder="New board name" />
			<button id="createBoard">Create Board</button>
		</div>

		<template id="list-template">
			<div class="list">
				<div class="list-header">
					<h4 class="list-title"></h4>
					<button class="add-card">＋</button>
				</div>
				<div class="cards"></div>
				<div class="add-card-row hidden">
					<input class="card-title" placeholder="Card title" />
					<input class="card-due" type="datetime-local" />
					<div class="row">
						<button class="save-card">Add</button>
						<button class="cancel-card">Cancel</button>
					</div>
				</div>
			</div>
		</template>

		<template id="card-template">
			<div class="card-item">
				<div class="card-main">
					<div class="card-title-text"></div>
					<div class="card-due-text muted"></div>
				</div>
				<div class="card-actions">
					<button class="complete">Done</button>
				</div>
				<div class="countdown muted"></div>
			</div>
		</template>

		<script>
			// Minimal client-side Trello-like app.
			// Data model stored in localStorage under key 'mt_data'
			const STORAGE_KEY = 'mt_data_v1';
			// DOM refs
			const boardsEl = document.getElementById('boards');
			const emptyEl = document.getElementById('empty');
			const createBoardBtn = document.getElementById('createBoard');
			const newBoardName = document.getElementById('newBoardName');

			const listTemplate = document.getElementById('list-template');
			const cardTemplate = document.getElementById('card-template');

			// app state
			let state = loadState();

			function loadState(){
				try{ const s = JSON.parse(localStorage.getItem(STORAGE_KEY)); return s || { boards: [] }; }catch(e){ return { boards: [] }; }
			}

			function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }



			function render(){
				boardsEl.innerHTML = '';
				if(state.boards.length === 0){ emptyEl.style.display = 'block'; } else { emptyEl.style.display = 'none'; }
				state.boards.forEach((board, bi) =>{
					const boardEl = document.createElement('section');
					boardEl.className = 'board';
					boardEl.innerHTML = `<div class="board-header"><h3>${escapeHtml(board.name)}</h3><button class="delete-board" title="Delete board">×</button></div><div class='lists'></div>`;
					// tag the element with the board id for external control/animations
					boardEl.dataset.boardId = board.id;
					const listsEl = boardEl.querySelector('.lists');
					
					// Delete button delegates to global requestDeleteBoard so we can animate first
					const deleteBtn = boardEl.querySelector('.delete-board');
					deleteBtn.addEventListener('click', () => {
						if (confirm('Are you sure you want to delete this board and all its contents?')) {
							if (window.requestDeleteBoard) window.requestDeleteBoard(board.id);
							else { state.boards.splice(bi, 1); saveState(); render(); }
						}
					});
					board.lists.forEach((list, li) =>{
						const node = listTemplate.content.cloneNode(true);
						const listEl = node.querySelector('.list');
						node.querySelector('.list-title').textContent = list.name;
						const addBtn = node.querySelector('.add-card');
						const addRow = node.querySelector('.add-card-row');
						const saveBtn = node.querySelector('.save-card');
						const cancelBtn = node.querySelector('.cancel-card');
						const titleInput = node.querySelector('.card-title');
						const dueInput = node.querySelector('.card-due');
						const cardsContainer = node.querySelector('.cards');

						addBtn.addEventListener('click', ()=>{ addRow.classList.toggle('hidden'); titleInput.focus(); });
						cancelBtn.addEventListener('click', ()=>{ addRow.classList.add('hidden'); titleInput.value=''; dueInput.value=''; });
						saveBtn.addEventListener('click', ()=>{
							const title = titleInput.value.trim();
							const due = dueInput.value ? new Date(dueInput.value).toISOString() : null;
							if(!title) return alert('Title required');
							const card = { id: Date.now()+Math.random(), title, due, created: new Date().toISOString(), done: false };
							state.boards[bi].lists[li].cards.push(card);
							saveState();
							render();
							// schedule notification if due
							scheduleReminder(card);
						});

						// render cards
						list.cards.forEach(card =>{
							const cnode = cardTemplate.content.cloneNode(true);
							cnode.querySelector('.card-title-text').textContent = card.title;
							cnode.querySelector('.card-due-text').textContent = card.due ? new Date(card.due).toLocaleString() : '';
							const completeBtn = cnode.querySelector('.complete');
							const cardEl = cnode.querySelector('.card-item');
							if(card.done) cardEl.classList.add('done');
							completeBtn.addEventListener('click', (ev)=>{
								card.done = !card.done;
								saveState(); render();
								// celebrate when a task is marked done
								if(card.done){ try{ if(window.showFireworks) window.showFireworks(cardEl); }catch(e){} }
							});
							// set countdown element dataset for ticking
							const countdown = cnode.querySelector('.countdown');
							if(card.due && !card.done){ countdown.dataset.due = card.due; }
							cardsContainer.appendChild(cnode);
							// entrance animation for the new card
							requestAnimationFrame(()=>{ if(cardEl) cardEl.classList.add('enter'); });
						});

						listsEl.appendChild(node);
					});

					boardsEl.appendChild(boardEl);
					// small entrance animation for the board
					requestAnimationFrame(()=> boardEl.classList.add('enter'));
				});
				// start countdown updater
				startTicker();
			}

			function escapeHtml(s){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]); }

			// basic ticker: updates countdowns and triggers notification if due
			let tickerId = null;
			function startTicker(){ if(tickerId) return; tickerId = setInterval(tick, 1000); tick(); }
			function stopTicker(){ if(tickerId){ clearInterval(tickerId); tickerId = null; } }

			function tick(){
				document.querySelectorAll('.countdown').forEach(el=>{
					const due = el.dataset.due; if(!due) { el.textContent = ''; return; }
					const ms = new Date(due) - new Date();
					if(ms <= 0){ el.textContent = 'Due now';
						// notify and clear dataset so we don't notify continuously
						if(!el.dataset.notified){ notify('Task due', el.previousElementSibling.querySelector('.card-title-text')?.textContent || 'Task is due'); el.dataset.notified = '1'; }
					} else {
						el.textContent = formatMs(ms);
					}
				});
			}

			function formatMs(ms){
				const s = Math.floor(ms/1000);
				const d = Math.floor(s/86400); const h = Math.floor((s%86400)/3600); const m = Math.floor((s%3600)/60); const sec = s%60;
				return (d?d+'d ':'') + (h?h+'h ':'') + (m?m+'m ':'') + sec+'s';
			}

			function notify(title, body){
				if(Notification.permission === 'granted'){ new Notification(title, { body }); }
				else if(Notification.permission !== 'denied'){
					Notification.requestPermission().then(p => { if(p==='granted') new Notification(title,{body}); });
				}
			}

			function scheduleReminder(card){
				if(!card.due) return;
				// For demo, rely on in-page tick to notify. In production, server-side scheduled tasks or push notifications required.
				// No-op here because tick will handle notification when due.
			}



			createBoardBtn.addEventListener('click', ()=>{
				const name = newBoardName.value.trim(); if(!name) return alert('Enter board name');
				state.boards.push({ id: Date.now()+Math.random(), name, lists: [ { name: 'To Do', cards: [] }, { name: 'Doing', cards: [] }, { name: 'Done', cards: [] } ] });
				newBoardName.value = '';
				saveState(); render();
			});

					render();

			// request notification permission on first load (non-blocking)
			if('Notification' in window && Notification.permission === 'default') Notification.requestPermission();
		</script>
		<script src="scripts.js"></script>
	</body>
</html>